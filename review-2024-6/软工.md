# 软件与软件危机

## 软件

在计算机系统的支持下，能完成特定功能和性能的**程序**(占10%~20%)、**数据**和相关的**文档**

### 分类

#### 按功能

- 系统软件
- 应用软件
- 支撑软件

## 软件危机

> 主要由软件问题引起

(由于落后的软件生产方式无法满足增长的需求)在计算机软件开发和维护过程中遇到的一系列严重问题

1. 如何开发软件
2. 如何维护软件

### 表现

- **计划**不准确
- **用户**不满意
- **质量**不可靠
- **系统**难维护
- **文档**不适合
- **成本**上升
- **开发**效率低

### 产生原因

1. 软件本身特点
    - 软件缺乏可见性
    - 可能存在测试阶段没能检测出来的错误
    - 软件维护通常意味着改正或修改原来的设计,使得软件较难维护
    - 软件规模庞大,随着规模增加复杂性呈指数上升
2. 软件开发维护方法不正确
    - **忽视软件需求分析重要性**,匆忙着手编程
    - 程序只是完整的软件产品的一个组成部分
    - 需要清除只重视程序而忽视软件配置其余成分的错误观念
    - 轻视维护是最大错误

### 消除方法

1. 对计算软件有**正确的认识**
2. 积累有效的**原理、概念、技术和方法**
3. 积极开发和使用**计算机辅助开发软件**
4. 探索更好的**管理措施**对开发过程进行管控

# 软件工程

> 由于软件危机的出现

指导计算机软件**开发和维护**的**工程学科**

1. 采用**工程**的概念、原理、技术和方法来**开发和维护**软件
2. 将**管理技术**与当前证明是正确的**技术方法**结合起来;
3. 强调使用**生存周期**方法学和**结构化技术**

## 基本原理

- 用分阶段软件生命周期计划进行质量管理
- 坚持阶段评审。
- 严格的产品控制。
- 现代程序设计技术。
- 结果应能清楚地审查。
- 开发小组人员少而精。
- 承认不断改进软件工程实践必要性。

## 方法学

软件生命周期中使用的一整套技术方法

### 三要素

**方法**,**工具**和**过程**

### 分类

#### 结构化方法学

结构化分析(SA)、设计(SD)、程序设计(SP)

每阶段结束前严格审查复复核

#### 面向对象方法学

面向对象分析(OOA)、设计(OOD)、程序设计(OOP)

- 用**对象分解**取代传统方法学功能分解
- 所有对象划分成类
- 按父类和子类关系组成**层级结构**系统
- 对象间仅通过**发送消息**相互联系

# 软件生命周期

**软件产品**\/**软件系统**从设计、投入使用到被淘汰的全过程

> 三个时期八个阶段, 从时间角度

## 软件定义时期

1. **问题定义**: 弄清客户要解决的问题
2. **可行性研究**: 确定软件开发可行性，输出《可行性研究报告》
3. **需求分析**: 明确客户需求，输出标准化《需求规格说明书》

## 软件开发时期

> 分为概要\/总体设计和详细设计

1. **总体设计**: 设计软件结构，确定功能模块和模块间关系，输出《总体设计说明书》
2. **详细设计**: 详细设计每个模块，确定所需算法和数据结构，输出《详细设计说明书》
3. **编码和单元测试**: 将详细设计用语言实现，并测试每个模块，输出软件产品
4. **综合测试**: 编写详细测试计划并严格按计划进行

## 软件维护时期

- 运行和维护

# 软件开发模型

## 软件过程

整个软件生命周期的系统**开发运行和维护过程**所实施的全部过程活动和任务的结构框架。通常用软件过程模型来描述软件过程

## 软件过程模型

### 传统软件过程模型

- 瀑布模型(线性顺序模型)
- 快速原型模型
- 增量模型
- 螺旋模型
- 喷泉模型

### 现代软件过程模型

- Rational统一过程(UML)
- 敏捷过程与极限编程
- 微软过程
- 基于构件的开发模型

### 瀑布模型

![瀑布模型](./images/waterfall.png)

将软件生命周期的各项活动规定为按固定顺序而连接的若干工作阶段，形如瀑布流水

以**文档**为驱动、适合于**软件需求确定**的软件项目开发

#### 三个时期

##### 定义时期

- 可行性研究
- 需求分析

##### 开发时期

- 总体设计
- 详细设计
- 编码
- 单元测试
- 系统测试
- 验收测试

##### 维护时期

- 运行与维护

#### 特点

> 线性和顺序的开发模型

1. 具有**顺序性**和**依赖性**
2. 推迟实现观点，编码前的各阶段主要考虑逻辑模型而不涉及具体实现
3. 观点有质量保证，每阶段必须完成规定**文档**，结束都要对所完成观点进行**评审**

#### 优点

1. 强迫开发人员采用**规范化方法**
2. 严格规定每阶段必须提交的**文档**
3. 要求每个截断交出产品经过**验证**

#### 缺点

1. 仅通过静态规格说明，无法及时验证需求是否正确、完整
2. 完全依赖书面说明，很容易导致软件产品不能真正满足用户需求
3. 不支持产品演化，不够灵活，软件产品难以维护

### 快速原型模型

![快速原型](./images/quick_proto.png)

![快速原型](images/quick_proto2.png)

快速建立可运行的程序，它完成的功能往往是最终产品功能的一个子集。

#### 优点

1. 开发的软件产品通常满足用户需求
2. 软件产品开发基本是线性过程

#### 缺点

1. 准确原型设计困难
2. 原型理解可能不同
3. 不利于开发人员创新

### 增量模型

![增量模型](images/incremental.png)

先完成一个系统子集的开发，再按同样的开发步骤增加功能 (系统子集),如此递增下去直至满足全部系统需求。

#### 优点

1. 短时间内可提交完成部分功能
2. 逐渐增加产品功能，用户适应产品快

#### 缺点

1. 增量构件划分以及集成困难
2. 容易退化为边做边改模型。

### 螺旋模型

![螺旋模型](images/spiral.png)

在每个阶段之前都增加了风险分析过程的快速原型模型，看作增加了风险分析的快速原型模型。

#### 优点

1. 利于把软件质量作为软件开发目标
2. 减少测试
3. 维护和开发不分开

### 缺点

- 风险估计困难

### 喷泉模型

![喷泉模型](images/fountain.png)

- 典型的面向对象软件过程模型，特点是迭代、无间隙。会将软件开发划分为多个阶段，但各个阶段无明显界限，并且可以迭代交义
- 迭代意味着模型中的开发活动常常需要重复多次，在迭代过程中不断地完善软件系统。无间隙是指在开发活动（如分析、设计、编码）之间不存在明显的边界

#### 优点

- 提高软件项目的开发效率，节省开发时间

#### 缺点

- 各个开发阶段是重叠的,开发过程中需要大量的开发人员,不利于项目的管理
- 求严格管理文档，审核的难度加大。
